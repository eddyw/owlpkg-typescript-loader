const fs = require('fs')
const { getOptions } = require('loader-utils')
const path = require('path')
const validateOptions = require('schema-utils')
const ts = require('typescript')
const util = require('util')

const async = require('async')
const crypto = require('crypto')

const {
  getDiagnostics,
  getMessageFromDiagnostic,
} = require('./diagnostics')

const schema = require('./schema')
const setupCompilerOptions = require('./setupCompilerOptions')
const transpiler = require('./transpiler')

const env = process.env.NODE_ENV || 'development'
const pkg = JSON.parse(
  fs.readFileSync(path.resolve(__dirname, '..', 'package.json'), { encoding: 'utf-8' }),
)

/**
 * @typedef {Object} CacheLoaderOptions
 * @property {string=} cacheIdentifier
 * @property {string=} cacheDirectory
 * @property {Function=} read
 * @property {Function=} write
 * @property {Function=} cacheKey
 */

/**
 * @typedef {Object} LoaderOptions
 * @property {string=} tslint
 * @property {string=} tslintFormatter
 * @property {string=} typescript
 * @property {string=} getCustomTransformers
 * @property {string=} jsconfig
 * @property {string=} tsconfig
 * @property {CacheLoaderOptions=} cache
 */

/**
 * @typedef DiagnosticMessage
 * @property {string} type - All messages are "diagnostic"
 * @property {string} code - Diagnostic or tslint code
 * @property {string|undefined} file - FileName
 * @property {string|undefined} text - source code
 * @property {number} line
 * @property {number} character
 * @property {string} severity - "warning" or "error"
 * @property {string} source - diagnostic or tslint error/warning
 * @property {string} content - message content
 */

/**
 * @typedef {Object} SourceMap
 * @property {number} [version=3] - Source Map version
 * @property {string} file - FileName
 * @property {Array<string>} sources - Array containing the fileName
 * @property {string} sourceRoot
 * @property {string} names
 * @property {number} mappings
 */

/**
 * @typedef FileItem
 * @property {number} version - File Version (Incremented in every change)
 * @property {string} content - Transpiled code
 * @property {boolean} emitted - If the file was transpiled
 * @property {SourceMap} map - SourceMap
 * @property {Array} diagnostics
 */

const inspect = (obj, depth = 0) => util.inspect(obj, true, depth, true)

/**
 * Format message the Webpack way
 * @param {DiagnosticMessage} message
 * @return {Error} - Error message that can be emitted by the loader
 */
const webpackFormatter = message => {
  const err = new Error()
  err.stack = ''
  err.message = (
    message.file
      ? `(${message.line},${message.character}): ${message.content}`
      : message.content
  )
  return err
}

/**
 * Generates a formatter function that will use tslint's
 * formatters
 * @param {*} tslintFormatter
 * @return {any}
 */
const generateTsLintFormatter = tslintFormatter => {
  /**
   * Format message the Webpack way
   * @param {DiagnosticMessage} message
   * @return {Error} - Error message that can be emitted by the loader
   */
  const newFormatter = message => {
    const err = new Error(
      // @ts-ignore
      tslintFormatter.format([
        {
          getFailure: () => message.content,
          getFileName: () => `${message.file}:${message.line + 1}:${message.character + 1}`,
          getRuleName: () => message.source,
          getRawLines: () => message.text,
          getRuleSeverity: () => message.severity,
          getStartPosition: () => ({
            getLineAndCharacter: () => ({
              line: message.line,
              character: message.character,
            }),
          }),
        },
      ]),
    )
    err.stack = ' '
    if (err.message.includes('\n', err.message.length - 2)) {
      err.message = err.message.substr(0, err.message.length - 2)
    }
    return err
  }
  return newFormatter
}

/**
 * Fixes SourceMap by specifying the correct filename
 * @param {string} file - FileName
 * @param {string} sourceMapText - JSON Stringified sourceMap
 * @return {SourceMap}
 */
const fixSourceMap = (file, sourceMapText) => {
  /**
   * @type {SourceMap}
   */
  const map = JSON.parse(sourceMapText || '{}')
  map.file = file
  map.sources = [file]
  return map
}

/**
 * Emits diagnostics as errors/warnings and keeps in cache
 * @param {Object} that - context of "this" (the loader)
 * @param {Array} diagnostics - an array of diagnostics generated by TS
 * @param {Array} [cacheDiagnostics=undefined] - a reference to an array where to cache diagnostic messages
 */
const emitDiagnostics = (that, diagnostics, cacheDiagnostics) => {
  if (Array.isArray(diagnostics)) {
    diagnostics.forEach(diagnostic => {
      const message = getMessageFromDiagnostic(typescript, diagnostic)
      const formattedMessage = formatter(message)

      if (message.severity === 'error') {
        that.emitError(formattedMessage)
      } else {
        that.emitWarning(formattedMessage)
      }
      if (Array.isArray(cacheDiagnostics)) {
        cacheDiagnostics.push({
          message: formattedMessage.message,
          severity: message.severity,
        })
      }
    })
  }
}

/**
 * Transpile source code to the target specified in CompilerOptions,
 * if source is not provided, transpiles using TSlanguageService
 * @param {string} file - fileName being transpiled (includes correct file in SourceMaps)
 * @param {string} source - Source Code
 */
const transpile = (file, source = null) => {
  listFiles[file].version += 1

  if (!source) {
    const output = service.getEmitOutput(file, false)
    const map = fixSourceMap(file, output.outputFiles[0].text)
    const content = output.outputFiles[1].text

    listFiles[file].content = content
    listFiles[file].map = map
  } else {
    const output = typescript.transpileModule(source, {
      compilerOptions,
      reportDiagnostics: false,
    })
    listFiles[file].content = output.outputText
    listFiles[file].map = fixSourceMap(file, output.sourceMapText)
  }
  listFiles[file].emitted = true
  listFiles[file].diagnostics = getDiagnostics(service, file)
}

/**
 * Removes content from memory and sourceMaps
 * @param {string} file - fileName
 */
const cleanAfterTranspile = file => {
  delete listFiles[file].content
  delete listFiles[file].map
  listFiles[file].emitted = false
}

/**
 * Watches file for changes, transpiles on the fly..
 * It allow for fast builds making the transpile code
 * available when the loader is called
 * @param {string} file - fileName
 */
const watchFile = file => {
  fs.watchFile(file, {
    persistent: true,
    interval: 10,
  }, (curr, prev) => {
    if (Number(curr.mtime) <= Number(prev.mtime)) return
    if (!listFiles[file].emitted) {
      transpile(file)
    }
  })
}

/**
 * Add file to list of files that keep version, content, and
 * diagnostic messages. Adds also to watched files
 * @param {string} file - fileName
 */
const addFileToList = file => {
  listFiles[file] = {
    map: null,
    version: 1,
    content: null,
    emitted: null,
    diagnostics: [],
  }
  listFileNames.push(file)
}

const cacheKey = (request, cacheOptions) => {
  const {
    cacheIdentifier,
    cacheDirectory,
  } = options.cache
  const hash = digest(`${cacheIdentifier}\n${request}`)

  return path.join(cacheDirectory, `${hash}.json`)
}
const read = (key, callback) => {
  fs.readFile(key, 'utf-8', (err, content) => {
    if (err) {
      callback(err)
      return
    }
    try {
      const data = JSON.parse(content)
      callback(null, data)
    } catch (e) {
      callback(e)
    }
  })
}
const digest = str => (
  crypto
    .createHash('md5')
    .update(str)
    .digest('hex')
)

const write = (key, data, callback) => {
  const dirname = path.dirname(key)
  const content = JSON.stringify(data)
  const sys = typescript.sys

  if (!directories.has(dirname)) {
    if (!sys.directoryExists(dirname)) {
      sys.createDirectory(dirname)
      directories.add(dirname)
    }
  }
  fs.writeFile(
    key,
    content,
    { encoding: 'utf-8' },
    callback,
  )
}

const getLoaderOptions = that => {
  /** @type {LoaderOptions} */
  const defaultOptions = Object.assign({
    getCustomTransformers: () => ({}),
  }, getOptions(that) || {})

  validateOptions(schema, defaultOptions, loaderName)

  const defaultCacheOptions = {
    cacheDirectory: path.resolve('.cache-typescript'),
    cacheIdentifier: `cache-typescript:${pkg.version} ${env}`,
    cacheKey,
    read,
    write,
  }

  if (defaultOptions.cache) {
    if (typeof defaultOptions.cache === 'object') {
      defaultOptions.cache = Object.assign({},
        defaultCacheOptions,
        defaultOptions.cache,
      )
    } else {
      defaultOptions.cache = defaultCacheOptions
    }
  }

  return defaultOptions
}

/** @type {LoaderOptions} */
let options

let initialized = false
let service = null
let compilerOptions = null
let formatter = webpackFormatter

/** @type {Object<string,FileItem>} */
const listFiles = {}
const listFileNames = []
const directories = new Set()
const fileCache = new Map()
const typescript = ts
const loaderName = '@owlpkg/typescript-loader'

function loader(source, sourceMap, meta) {
  const callback = this.async()
  const file = this.resourcePath
  const data = this.data
  const dependencies = this.getDependencies().concat(this.loaders.map(l => l.path))
  const contextDependencies = this.getContextDependencies()
  const cacheDiagnostics = []

  // If the file and result should be cached
  let cache = true

  if (this.cacheable) {
    // The loader result is cacheable
    this.cacheable(true)
  }

  if (!initialized) {
    initialized = true

    compilerOptions = setupCompilerOptions(typescript, options, loaderName)

    if (typeof options.tslint !== 'undefined') {
      const tslint = require('tslint')
      const enableTsLintLanguageService = require('./TsLintLangService')
      enableTsLintLanguageService(typescript, options.tslint)

      if (options.tslintFormatter) {
        const TsLintFormatter = tslint.findFormatter(options.tslintFormatter)
        if (TsLintFormatter) {
          const tslintFormatter = new TsLintFormatter()
          formatter = generateTsLintFormatter(tslintFormatter)
        }
      }
    }

    const moduleResolutionCache = ts.createModuleResolutionCache(
      process.cwd(),
      fileName => ts.sys.useCaseSensitiveFileNames
        ? fileName
        : fileName.toLowerCase(),
    )
    const moduleResolutionHost = {
      fileExists: typescript.sys.fileExists,
      readFile: typescript.sys.readFile,
    }

    service = typescript.createLanguageService({
      getScriptFileNames() { return listFileNames },
      getCurrentDirectory() { return process.cwd() },
      getCustomTransformers() { return ({}) /* TODO! */ },
      getDefaultLibFileName() { return typescript.getDefaultLibFilePath(compilerOptions) },
      getCompilationSettings() { return compilerOptions },
      useCaseSensitiveFileNames() { return typescript.sys.useCaseSensitiveFileNames },

      readFile(fileName, encoding) {
        if (fileName === file) return source
        if (fileCache.has(fileName)) return fileCache.get(fileName)

        const fileContent = ts.sys.readFile(fileName, encoding)
        fileCache.set(fileName, fileContent)
        return fileContent
      },
      fileExists(fileName) {
        if (file === fileName) return true
        return typescript.sys.fileExists(fileName)
      },
      getScriptVersion(fileName) {
        if (!listFiles[fileName]) return undefined
        return listFiles[fileName].version.toString()
      },
      getScriptSnapshot(fileName) {
        const fileContent = typescript.sys.readFile(fileName, 'utf-8')
        return fileContent
          ? typescript.ScriptSnapshot.fromString(fileContent)
          : undefined
      },
      resolveModuleNames(moduleNames, containingFile) {
        const resolvedModules = []
        for (const moduleName of moduleNames) {
          const result = typescript.resolveModuleName(
            moduleName,
            containingFile,
            compilerOptions,
            moduleResolutionHost,
            moduleResolutionCache,
          )
          if (result.resolvedModule) {
            resolvedModules.push(result.resolvedModule)
          } else {
            // TODO: What about paths/alias?
            resolvedModules.push({
              resolvedFileName: moduleName,
              extension: '',
              isExternalLibraryImport: true,
              packageId: undefined,
            })
          }
        }
        return resolvedModules
      },
    },
      typescript.createDocumentRegistry(
        typescript.sys.useCaseSensitiveFileNames,
      ),
    )
  }

  /**
   * Watch for changes in the file,
   * so it's transpiled on the background and the transpiled
   * file is (hopefully) available before Webpack gets here
   */
  if (!listFiles[file]) {
    addFileToList(file)
    watchFile(file)
    transpile(file, source)
  }

  /**
   * If file was not transpiled by the watcher,
   * then transpile here
   */
  if (!listFiles[file].emitted) {
    transpile(file)
  }

  /**
   * Print diagnostics errors and warnings,
   * keep diagnostics in cache
   */
  emitDiagnostics(
    this,
    listFiles[file].diagnostics,
    cacheDiagnostics,
  )

  if (!options.cache) {
    callback(
      null,
      listFiles[file].content,
      listFiles[file].map,
    )
    cleanAfterTranspile(file)
  } else {
    /**
     * Credits to devs of cache-loader
     * https://github.com/webpack-contrib/cache-loader/blob/master/src/index.js#L42
     */
    const toDepDetails = (dep, mapCallback) => {
      fs.stat(dep, (err, stats) => {
        if (err) return mapCallback(err)

        const mtime = stats.mtime.getTime()

        if (mtime / 1000 >= Math.floor(data.startTime / 1000)) {
          cache = false
        }
        mapCallback(null, {
          path: dep,
          mtime,
        })
      })
    }

    async.parallel([
      cb => async.mapLimit(dependencies, 20, toDepDetails, cb),
      cb => async.mapLimit(contextDependencies, 20, toDepDetails, cb),
    ], (err, taskResults) => {
      if (err || !cache) {
        callback(
          null,
          listFiles[file].content,
          listFiles[file].map,
        )
        cleanAfterTranspile(file)
        return
      }
      const [
        deps,
        contextDeps,
      ] = taskResults
      write(data.cacheKey, {
        diagnostics: cacheDiagnostics,
        dependencies: deps,
        remainingRequest: data.remainingRequest,
        contextDependencies: contextDeps,
        result: [
          listFiles[file].content,
          listFiles[file].map,
        ],
      }, () => {
        callback(
          null,
          listFiles[file].content,
          listFiles[file].map,
        )
        cleanAfterTranspile(file)
      })
    })
  } // if options.cache
}

function pitch(remainingRequest, precedingRequest, dataInput) {
  if (!options) {
    options = getLoaderOptions(this)
  }

  if (options.cache) {
    const data = dataInput
    const callback = this.async()

    data.remainingRequest = remainingRequest
    data.cacheKey = cacheKey(remainingRequest)

    read(data.cacheKey, (err, cacheData) => {
      if (err || cacheData.remainingRequest !== remainingRequest) return callback()
      async.each(
        cacheData.dependencies.concat(cacheData.contextDependencies),
        (dependency, cb) => {
          fs.stat(dependency.path, (statsErr, stats) => {
            if (statsErr) return cb(statsErr)
            if (stats.mtime.getTime() !== dependency.mtime) return cb(true)
            cb()
          })
        },
        asyncErr => {
          if (asyncErr) {
            data.startTime = Date.now()
            return callback()
          }
          cacheData.dependencies.forEach(dep => this.addDependency(dep.path))
          cacheData.contextDependencies.forEach(dep => this.addContextDependency(dep.path))
          if (Array.isArray(cacheData.diagnostics)) {
            cacheData.diagnostics.forEach(diagnostic => {
              const errDiagnostic = new Error()
              errDiagnostic.message = diagnostic.message
              errDiagnostic.stack = ''
              if (diagnostic.severity === 'error') {
                this.emitError(errDiagnostic)
              } else {
                this.emitWarning(errDiagnostic)
              }
            })
          }
          callback(null, ...cacheData.result)
        },
      ) // async.each
    }) // read(...)
  } // if options.cache
}

loader.pitch = pitch
module.exports = loader
